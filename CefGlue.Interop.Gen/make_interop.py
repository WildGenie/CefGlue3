#
# Copyright (C) Xilium CefGlue Project
#

from cef_parser import *
import sys
import schema
import file_util

#
# settings
#
indent = '    '

#
# Common
#
def get_func_parts(func, slot, is_global = False):
    virtual = isinstance(func, obj_function_virtual)
    capi_parts = func.get_capi_parts()

    csn_name = capi_parts['name']
    if not virtual:
        if is_global:
            if csn_name[:4] == 'cef_':
                csn_name = csn_name[4:]
        else:
            csn_name = get_capi_name(func.get_name(), False, None)
            prefix = func.parent.get_capi_name()
            if prefix[-2:] == '_t':
                prefix = prefix[:-2]
            if prefix[:3] == 'cef':
                subprefix = prefix[3:]
                pos = csn_name.find(subprefix)
                if pos >= 0:
                    csn_name = csn_name[:pos]

    csn_args = []
    for carg in capi_parts['args']:
        type = schema.c2cs_type( carg[:carg.rindex(' ')] )
        name = schema.quote_name( carg[carg.rindex(' ')+1:] )
        csn_args.append({'name' : name, 'type' : type})

    iname = schema.get_iname(func.parent) if virtual else ''
    return {
        'basefunc': False,
        'virtual': virtual,
        'obj': func,
        'slot': '%x' % slot,
        'name': func.get_name(),
        'field_name': f'_{func.get_capi_name()}',
        'delegate_type': f'{func.get_capi_name()}_delegate',
        'delegate_slot': '_ds%x' % slot,
        'capi_name': capi_parts['name'],
        'capi_retval': capi_parts['retval'],
        'capi_args': capi_parts['args'],
        'csn_name': csn_name,
        'csn_retval': schema.c2cs_type(capi_parts['retval']),
        'csn_args': csn_args,
        'csn_entrypoint': capi_parts['name'],
        'csn_args_proto': ', '.join(
            map(lambda x: '%s %s' % (x['type'], x['name']), csn_args)
        ),
        'iname': iname,
    }

def get_base_func(cls, slot, name, cname):
    return {
            'basefunc': True,
            'virtual': True,
            'obj': None,
            'slot': '%x' % slot,
            'name': name,
            'field_name': '_base._%s' % cname,
            'delegate_type': '%s_delegate' % cname,
            'delegate_slot': '_ds%x' % slot,
            'capi_name': cname,
            'capi_retval': 'int',
            'capi_args': ['%s* self' % cls.get_capi_name()],

            'csn_name': cname,
            'csn_retval': 'int',
            'csn_args': [ { 'type': '%s*' % cls.get_capi_name(), 'name': 'self' } ],

            'csn_args_proto': '%s* self' % cls.get_capi_name(),

            'iname': schema.get_iname(cls),
        }

def get_base_funcs(cls):
    return [
        get_base_func(cls, 0, 'AddRef', 'add_ref'),
        get_base_func(cls, 1, 'Release', 'release'),
        get_base_func(cls, 2, 'GetRefCt', 'get_refct'),
        ]

def make_file_header():
    return """//
// DO NOT MODIFY! THIS IS AUTOGENERATED FILE!
//
""";

def append_dllimport(result, func):
    result.append('// %(name)s' % func)
    result.append('[DllImport(%(nm_class)s.DllName, EntryPoint = "%(entrypoint)s", CallingConvention = %(nm_class)s.CEF_CALL)]' % { 'nm_class': schema.nm_class, 'entrypoint': func['csn_entrypoint'] })
    result.append('public static extern %(csn_retval)s %(csn_name)s(%(csn_args_proto)s);' % func)
    result.append('')

#
# Generating Introp/Classes.X/*.g.cs
#
def make_struct_file(cls):
    body = []
    body.append('using System;')
    body.append('using System.Diagnostics.CodeAnalysis;')
    body.append('using System.Runtime.InteropServices;')
    body.append('using System.Security;')
    body.append('');

    body.append('[StructLayout(LayoutKind.Sequential, Pack = %s)]' % schema.CEF_ALIGN)
    body.append('[SuppressMessage("Microsoft.Design", "CA1049:TypesThatOwnNativeResourcesShouldBeDisposable")]')
    body.append('internal unsafe struct %s' % schema.get_iname(cls))
    body.append('{')
    body.append( indent + ('\n' + indent + indent).join( make_struct_members(cls) ) )
    body.append('}')

    return make_file_header() + \
"""namespace %(namespace)s
{
%(body)s
}
""" % {
        'namespace': schema.interop_namespace,
        'body': indent + ('\n'+indent).join(body)
      }

def get_funcs(cls, base = True):
    funcs = []

    if base:
        funcs.extend(iter(get_base_funcs(cls)))
    funcs.extend(
        get_func_parts(func, i)
        for i, func in enumerate(cls.get_virtual_funcs(), start=3)
    )

    return funcs

def make_struct_members(cls):
    funcs = get_funcs(cls)

    delegate_visibility = "private" if schema.is_proxy(cls) else "internal"
    static_funcs = [get_func_parts(func, 0) for func in cls.get_static_funcs()]
    result = ['internal cef_base_t _base;']
    result.extend(
        'internal IntPtr %(field_name)s;' % func
        for func in funcs
        if not func['basefunc']
    )

    result.append('')

    for func in static_funcs:
        append_dllimport(result, func)

    for func in funcs:
        postfixs = schema.get_platform_retval_postfixs(func['csn_retval'])
        for px in postfixs:
            func['px'] = px
            result.extend(
                (
                    '[UnmanagedFunctionPointer(%s)]' % schema.CEF_CALLBACK,
                    '#if !DEBUG',
                    '[SuppressUnmanagedCodeSecurity]',
                    '#endif',
                    delegate_visibility
                    + ' delegate %(csn_retval)s%(px)s %(delegate_type)s%(px)s(%(csn_args_proto)s);'
                    % func,
                    '',
                )
            )

    for func in funcs:
        if schema.is_proxy(cls):
            postfixs = schema.get_platform_retval_postfixs(func['csn_retval'])
            for px in postfixs:
                func['px'] = px
                result.extend(
                    (
                        '// %(name)s' % func,
                        'private static IntPtr _p%(slot)s%(px)s;' % func,
                        'private static %(delegate_type)s%(px)s _d%(slot)s%(px)s;'
                        % func,
                        '',
                        'public static %(csn_retval)s%(px)s %(csn_name)s%(px)s(%(csn_args_proto)s)'
                        % func,
                        '{',
                        '    %(delegate_type)s%(px)s d;' % func,
                        '    var p = self->%(field_name)s;' % func,
                        '    if (p == _p%(slot)s%(px)s) { d = _d%(slot)s%(px)s; }'
                        % func,
                        '    else',
                        '    {',
                        '        d = (%(delegate_type)s%(px)s)Marshal.GetDelegateForFunctionPointer(p, typeof(%(delegate_type)s%(px)s));'
                        % func,
                        '        if (_p%(slot)s%(px)s == IntPtr.Zero) { _d%(slot)s%(px)s = d; _p%(slot)s%(px)s = p; }'
                        % func,
                        '    }',
                    )
                )

                args = ', '.join(map(lambda x: x['name'], func['csn_args']))
                if func['csn_retval'] == 'void':
                    result.append('    d(%s);' % args)
                else:
                    result.append('    return d(%s);' % args)
                result.extend(('}', ''))
    if schema.is_handler(cls):
        iname = schema.get_iname(cls)
        result.extend(
            (
                'private static int _sizeof;',
                '',
                'static %s()' % iname,
                '{',
                indent + '_sizeof = Marshal.SizeOf(typeof(%s));' % iname,
                '}',
                '',
                'internal static %s* Alloc()' % iname,
                '{',
                indent
                + 'var ptr = (%s*)Marshal.AllocHGlobal(_sizeof);' % iname,
                indent + '*ptr = new %s();' % iname,
                f'{indent}ptr->_base._size = (UIntPtr)_sizeof;',
                f'{indent}return ptr;',
                '}',
                '',
                'internal static void Free(%s* ptr)' % iname,
                '{',
                f'{indent}Marshal.FreeHGlobal((IntPtr)ptr);',
                '}',
                '',
            )
        )

    return result

#
# Generating Introp/libcef.g.cs
#
def make_libcef_file(header):
    result = []

    for func in header.get_funcs():
        append_dllimport(result, get_func_parts(func, 0, True))

    body = []
    body.append('using System;')
    body.append('using System.Runtime.InteropServices;')
    body.append('using System.Diagnostics.CodeAnalysis;')
    body.append('');

    body.append('internal static unsafe partial class %s' % schema.nm_class)
    body.append('{')
    body.append( indent + ('\n' + indent + indent).join( result ) )
    body.append('}')

    return make_file_header() + \
"""namespace %(namespace)s
{
%(body)s
}
""" % {
        'namespace': schema.interop_namespace,
        'body': indent + ('\n'+indent).join(body)
      }

#
# Generating C# wrappers
#
def make_wrapper_g_file(cls):
    body = [
        'using System;',
        'using System.Collections.Generic;',
        'using System.Diagnostics;',
        'using System.Runtime.InteropServices;',
        'using %s;' % schema.interop_namespace,
        '',
    ]


    body.extend('// %s' % line for line in schema.get_overview(cls))
    if schema.is_proxy(cls):
        body.extend(
            (
                'public sealed unsafe partial class %s : IDisposable'
                % schema.cpp2csname(cls.get_name()),
                '{',
            )
        )

        body.extend(
            (
                indent + ('\n' + indent + indent).join(make_proxy_g_body(cls)),
                '}',
            )
        )

    if schema.is_handler(cls):
        body.extend(
            (
                'public abstract unsafe partial class %s'
                % schema.cpp2csname(cls.get_name()),
                '{',
            )
        )

        body.extend(
            (
                indent
                + ('\n' + indent + indent).join(make_handler_g_body(cls)),
                '}',
            )
        )

        return make_file_header() + \
    """namespace %(namespace)s
{
%(body)s
}
""" % {
            'namespace': schema.namespace,
            'body': indent + ('\n'+indent).join(body)
          }

#
# make proxy body
#
def make_proxy_g_body(cls):
    csname = schema.cpp2csname(cls.get_name())
    iname = schema.get_iname(cls)

    return [
        'internal static %(csname)s FromNative(%(iname)s* ptr)'
        % {'csname': csname, 'iname': iname},
        '{',
        indent + 'return new %s(ptr);' % csname,
        '}',
        '',
        'internal static %(csname)s FromNativeOrNull(%(iname)s* ptr)'
        % {'csname': csname, 'iname': iname},
        '{',
        f'{indent}if (ptr == null) return null;',
        indent + 'return new %s(ptr);' % csname,
        '}',
        '',
        'private %s* _self;' % iname,
        '',
        'private %(csname)s(%(iname)s* ptr)'
        % {'csname': csname, 'iname': iname},
        '{',
        indent + 'if (ptr == null) throw new ArgumentNullException("ptr");',
        f'{indent}_self = ptr;',
        '}',
        '',
        '~%s()' % csname,
        '{',
        f'{indent}if (_self != null)',
        indent + '{',
        indent + indent + 'Release();',
        indent + indent + '_self = null;',
        indent + '}',
        '}',
        '',
        'public void Dispose()',
        '{',
        f'{indent}if (_self != null)',
        indent + '{',
        indent + indent + 'Release();',
        indent + indent + '_self = null;',
        indent + '}',
        f'{indent}GC.SuppressFinalize(this);',
        '}',
        '',
        'internal int AddRef()',
        '{',
        indent + 'return %(iname)s.add_ref(_self);' % {'iname': iname},
        '}',
        '',
        'internal int Release()',
        '{',
        indent + 'return %(iname)s.release(_self);' % {'iname': iname},
        '}',
        '',
        'internal int RefCt',
        '{',
        indent
        + 'get { return %(iname)s.get_refct(_self); }' % {'iname': iname},
        '}',
        '',
        'internal %(iname)s* ToNative()' % {'iname': iname},
        '{',
        f'{indent}AddRef();',
        f'{indent}return _self;',
        '}',
    ]

#
# make handler body
#
def make_handler_g_body(cls):
    csname = schema.cpp2csname(cls.get_name())
    iname = schema.get_iname(cls)

    funcs = get_funcs(cls)

    result = [
        'private static Dictionary<IntPtr, %(csname)s> _roots = new Dictionary<IntPtr, %(csname)s>();'
        % {'csname': csname},
        '',
        'private int _refct;',
        'private %s* _self;' % iname,
        '',
        'protected object SyncRoot { get { return this; } }',
        '',
    ]


    if schema.is_reversible(cls):
        result.extend(
            (
                'internal static %s FromNativeOrNull(%s* ptr)'
                % (csname, iname),
                '{',
            )
        )

        result.append(indent + '%s value = null;' % csname)
        result.append(f'{indent}bool found;')
        result.append(f'{indent}lock (_roots)')
        result.append(indent + '{')
        result.append(indent + indent + 'found = _roots.TryGetValue((IntPtr)ptr, out value);')
        result.append(indent + '}')
        result.extend((f'{indent}return found ? value : null;', '}', ''))
        result.extend(
            ('internal static %s FromNative(%s* ptr)' % (csname, iname), '{')
        )

        result.append(f'{indent}var value = FromNativeOrNull(ptr);')
        result.append(indent + 'if (value == null) throw ExceptionBuilder.ObjectNotFound();')
        result.extend((f'{indent}return value;', '}', ''))
    result.extend(
        'private %(iname)s.%(delegate_type)s %(delegate_slot)s;' % func
        for func in funcs
    )

    result.append('')

    result.extend(('protected %s()' % csname, '{'))
    result.extend((indent + '_self = %s.Alloc();' % iname, ''))
    for func in funcs:
        result.append(indent + '%(delegate_slot)s = new %(iname)s.%(delegate_type)s(%(csn_name)s);' % func)
        result.append(indent + '_self->%(field_name)s = Marshal.GetFunctionPointerForDelegate(%(delegate_slot)s);' % func)
    result.extend(('}', ''))
    result.extend(('~%s()' % csname, '{'))
    result.extend(
        (
            f'{indent}Dispose(false);',
            '}',
            '',
            'protected virtual void Dispose(bool disposing)',
            '{',
        )
    )

    # result.append(indent + '_disposed = true;')
    result.append(f'{indent}if (_self != null)')
    result.append(indent + '{')
    result.append(indent + indent + '%s.Free(_self);' % iname)
    result.append(indent + indent + '_self = null;')
    result.extend((indent + '}', '}', ''))
    result.extend(('private int add_ref(%s* self)' % iname, '{'))
    result.append(f'{indent}lock (SyncRoot)')
    result.append(indent + '{')
    result.append(indent + indent + 'var result = ++_refct;')
    result.append(indent + indent + 'if (result == 1)')
    result.append(indent + indent + '{')
    result.append(indent + indent + indent + 'lock (_roots) { _roots.Add((IntPtr)_self, this); }')
    result.append(indent + indent + '}')
    result.append(indent + indent + 'return result;')
    result.extend((indent + '}', '}', ''))
    result.extend(('private int release(%s* self)' % iname, '{'))
    result.append(f'{indent}lock (SyncRoot)')
    result.append(indent + '{')
    result.append(indent + indent + 'var result = --_refct;')
    result.append(indent + indent + 'if (result == 0)')
    result.append(indent + indent + '{')
    result.append(indent + indent + indent + 'lock (_roots) { _roots.Remove((IntPtr)_self); }')
    result.append(indent + indent + '}')
    result.append(indent + indent + 'return result;')
    result.extend((indent + '}', '}', ''))
    result.extend(('private int get_refct(%s* self)' % iname, '{'))
    result.extend((f'{indent}return _refct;', '}', ''))
    result.extend(('internal %s* ToNative()' % iname, '{'))
    result.append(f'{indent}add_ref(_self);')
    result.extend((f'{indent}return _self;', '}', '', '[Conditional("DEBUG")]'))
    result.extend(('private void CheckSelf(%s* self)' % iname, '{'))
    result.extend(
        (
            indent
            + 'if (_self != self) throw ExceptionBuilder.InvalidSelfReference();',
            '}',
            '',
        )
    )

    return result

#
# Generating impl templates
#
def make_impl_tmpl_file(cls):
    body = [
        'using System;',
        'using System.Collections.Generic;',
        'using System.Diagnostics;',
        'using System.Runtime.InteropServices;',
        'using %s;' % schema.interop_namespace,
        '',
    ]


    append_xmldoc(body, cls.get_comment())

    if schema.is_proxy(cls):
        body.extend(
            (
                'public sealed unsafe partial class %s'
                % schema.cpp2csname(cls.get_name()),
                '{',
            )
        )

        body.extend(
            (
                indent
                + ('\n' + indent + indent).join(
                    make_proxy_impl_tmpl_body(cls)
                ),
                '}',
            )
        )

    if schema.is_handler(cls):
        body.extend(
            (
                'public abstract unsafe partial class %s'
                % schema.cpp2csname(cls.get_name()),
                '{',
            )
        )

        body.extend(
            (
                indent
                + ('\n' + indent + indent).join(
                    make_handler_impl_tmpl_body(cls)
                ),
                '}',
            )
        )

        return \
    """namespace %(namespace)s
{
%(body)s
}
""" % {
            'namespace': schema.namespace,
            'body': indent + ('\n'+indent).join(body)
          }



#
# make proxy impl tmpl body
#
def make_proxy_impl_tmpl_body(cls):
    csname = schema.cpp2csname(cls.get_name())
    iname = schema.get_iname(cls)
    funcs = get_funcs(cls, False)
    static_funcs = []
    for func in cls.get_static_funcs():
        static_funcs.append( get_func_parts(func, 0) )

    result = []

    for func in static_funcs:
        append_xmldoc(result, func['obj'].get_comment())
        result.append('public static %(csn_retval)s %(name)s(%(csn_args_proto)s)' % func)
        result.append('{')
        result.append('    throw new NotImplementedException(); // TODO: %(csname)s.%(name)s' % { 'csname': csname, 'name' : func['name'] })
        result.append('}')
        result.append('')

    for func in funcs:
        name = func['name']
        retval = func['csn_retval']
        args = func['csn_args_proto']
        if func['csn_args'][0]['name'] == 'self':
            args = ', '.join(map(lambda x: '%s %s' % (x['type'], x['name']), func['csn_args'][1:]))

        append_xmldoc(result, func['obj'].get_comment())

        result.append('public %s %s(%s)' % (retval, name, args))
        result.append('{')
        result.append('    throw new NotImplementedException(); // TODO: %(csname)s.%(name)s' % { 'csname': csname, 'name' : func['name'] })
        result.append('}')
        result.append('')

    return result

#
# make handler impl tmpl body
#
def make_handler_impl_tmpl_body(cls):
    csname = schema.cpp2csname(cls.get_name())
    iname = schema.get_iname(cls)
    funcs = get_funcs(cls, False)
    static_funcs = []
    for func in cls.get_static_funcs():
        static_funcs.append( get_func_parts(func, 0) )

    result = []

    for func in static_funcs:
        append_xmldoc(result, func['obj'].get_comment())
        result.append('public static %(csn_retval)s %(name)s(%(csn_args_proto)s)' % func)
        result.append('{')
        result.append('    throw new NotImplementedException(); // TODO: %(csname)s.%(name)s' % { 'csname': csname, 'name' : func['name'] })
        result.append('}')
        result.append('')

    for func in funcs:
        result.append('private %s %s(%s)' % (func['csn_retval'], func['csn_name'], func['csn_args_proto']))
        result.append('{')
        result.append(indent + 'CheckSelf(self);')
        result.append(indent + 'throw new NotImplementedException(); // TODO: %(csname)s.%(name)s' % { 'csname': csname, 'name' : func['name'] })
        result.append('}')
        result.append('')

        name = func['name']
        retval = func['csn_retval']
        args = func['csn_args_proto']
        if func['csn_args'][0]['name'] == 'self':
            args = ', '.join(map(lambda x: '%s %s' % (x['type'], x['name']), func['csn_args'][1:]))

        append_xmldoc(result, func['obj'].get_comment())

        result.append('// protected abstract %s %s(%s);' % (retval, name, args))
        result.append('')

    return result


def append_xmldoc(result, lines):
    result.append('/// <summary>')
    for line in lines:
        if line != '/' and not (line is None):
            line = line.strip()
            if line != '':
                result.append('/// %s' % line.strip())
    result.append('/// </summary>')
    return


def make_version_cs(content):
    result = []

    result.append('public const int CEF_VERSION_MAJOR = %s;' % __get_version_constant(content, "CEF_VERSION_MAJOR"))
    result.append('public const int CEF_REVISION = %s;' % __get_version_constant(content, "CEF_REVISION"))
    result.append('public const int COPYRIGHT_YEAR = %s;' % __get_version_constant(content, "COPYRIGHT_YEAR"))
    result.append("");

    result.append('public const int CHROME_VERSION_MAJOR = %s;' % __get_version_constant(content, "CHROME_VERSION_MAJOR"))
    result.append('public const int CHROME_VERSION_MINOR = %s;' % __get_version_constant(content, "CHROME_VERSION_MINOR"))
    result.append('public const int CHROME_VERSION_BUILD = %s;' % __get_version_constant(content, "CHROME_VERSION_BUILD"))
    result.append('public const int CHROME_VERSION_PATCH = %s;' % __get_version_constant(content, "CHROME_VERSION_PATCH"))
    result.append("");

    result.append('public const string CEF_API_HASH_UNIVERSAL = %s;' % __get_version_constant(content, "CEF_API_HASH_UNIVERSAL"))
    result.append("");
    result.append('public const string CEF_API_HASH_PLATFORM_WIN = %s;' % __get_version_constant(content, "CEF_API_HASH_PLATFORM", "WIN"))
    result.append('public const string CEF_API_HASH_PLATFORM_MACOSX = %s;' % __get_version_constant(content, "CEF_API_HASH_PLATFORM", "MACOSX"))
    result.append('public const string CEF_API_HASH_PLATFORM_LINUX = %s;' % __get_version_constant(content, "CEF_API_HASH_PLATFORM", "LINUX"))

    body = []
    body.append('using System;')
    body.append('using System.Runtime.InteropServices;')
    body.append('using System.Diagnostics.CodeAnalysis;')
    body.append('');

    body.append('internal static unsafe partial class %s' % schema.nm_class)
    body.append('{')
    body.append( indent + ('\n' + indent + indent).join( result ) )
    body.append('}')

    return make_file_header() + \
"""namespace %(namespace)s
{
%(body)s
}
""" % {
        'namespace': schema.interop_namespace,
        'body': indent + ('\n'+indent).join(body)
      }

def __get_version_constant(content, name, platform = None):
    if platform is None:
        m = re.search('^#define\s+' + name + '\s+(.*?)\n', content, re.MULTILINE)
        if m is None:
            raise Exception('Could not find ' + name + ' constant.');
        value = m.group(1)
    else:
        m = re.search('\n#e?l?if defined\(OS_' + platform + '\)\n+#define\s+' + name + '\s+(.*?)\n', content, re.DOTALL)
        if m is None:
            raise Exception('Could not find ' + name + ' constant.');
        value = m.group(1)
    return value

#
# Main
#
def write_interop(header, filepath, backup, schema_name, cppheaderdir):
    writect = 0

    schema.load(schema_name, header)

    # validate: class role must be defined for all header classes
    for cls in header.get_classes():
        if not schema.is_handler(cls) and not schema.is_proxy(cls):
            msg = 'Class role must be defined. Class name %s.' % cls.get_name()
            sys.stdout.write('ERROR! %s\n' % msg)
            raise Exception(msg)

    # structs
    for cls in header.get_classes():
        content = make_struct_file(cls)
        writect += update_file(filepath + '/' + schema.struct_path, cls.get_capi_name() + ".g.cs", content, backup)

    # libcef.g.cs
    writect += update_file(filepath + '/' + schema.libcef_path, schema.libcef_filename, make_libcef_file(header), backup)
    
    # wrapper
    for cls in header.get_classes():
        content = make_wrapper_g_file(cls)
        writect += update_file(filepath + '/' + schema.wrapper_g_path, schema.cpp2csname(cls.get_name()) + ".g.cs", content, backup)

    # userdata    
    userdatacls = obj_class(header, 'CefUserData', '', 'CefUserData', '', '', '')
    content = make_struct_file(userdatacls)
    writect += update_file(filepath + '/' + schema.struct_path, userdatacls.get_capi_name() + ".g.cs", content, backup)
    content = make_wrapper_g_file(userdatacls)
    writect += update_file(filepath + '/' + schema.wrapper_g_path, schema.cpp2csname(userdatacls.get_name()) + ".g.cs", content, backup)
    
    # impl template
    for cls in header.get_classes():
        content = make_impl_tmpl_file(cls)
        tmplpath = schema.handler_tmpl_path
        if schema.is_proxy(cls):
            tmplpath = schema.proxy_tmpl_path
        writect += update_file('./' + tmplpath, schema.cpp2csname(cls.get_name()) + ".tmpl.g.cs", content, backup)

    # process cef_version_h
    content = make_version_cs(read_file(cppheaderdir + '/' + 'cef_version.h'))
    writect += update_file(filepath + '/' + schema.libcef_path, schema.libcef_version_filename, content, backup)

    return writect

#
# Utils
#
def update_file(dir, filename, content, backup):
    if not os.path.isdir(dir):
        os.makedirs(dir)

    sys.stdout.write(filename + "... ")
    filename = dir + "/" + filename

    if path_exists(filename):
        oldcontent = read_file(filename)
    else:
        oldcontent = ''

    if content != oldcontent:
        if backup and oldcontent != '':
            backup_file(filename)
        write_file(filename, content)
        sys.stdout.write("updated.\n")
        return 1

    sys.stdout.write("up-to-date.\n")
    return 0
